from __future__ import annotations

from dataclasses import dataclass
from requests_toolbelt.sessions import BaseUrlSession
from typing import Optional
from time import sleep, time
from warnings import warn

from codeocean.models.computation import Computation, ComputationState, RunParams
# Re-exports for backward compatibility
from codeocean.models.computation import (  # noqa: F401
    ComputationEndStatus,
    Param,
    PipelineProcess,
    InputDataAsset,
    DataAssetsRunParam,
    NamedRunParam,
    PipelineProcessParams,
)
from codeocean.models.data_asset import DataAssetAttachParams, DataAssetAttachResults
from codeocean.models.folder import FileURLs, Folder, DownloadFileURL


@dataclass
class Computations:
    """Client for interacting with Code Ocean computation APIs."""

    client: BaseUrlSession

    def get_computation(self, computation_id: str) -> Computation:
        """Retrieve metadata and status information for a specific computation by its ID."""
        res = self.client.get(f"computations/{computation_id}")

        return Computation.from_dict(res.json())

    def run_capsule(self, run_params: RunParams) -> Computation:
        """
        Execute a capsule or pipeline with specified parameters and data assets.

        For capsule execution: Set run_params.capsule_id and optionally provide data_assets,
        parameters, or named_parameters.

        For pipeline execution: Set run_params.pipeline_id and optionally provide data_assets,
        processes (with process-specific parameters), and nextflow_profile configuration.

        """
        res = self.client.post("computations", json=run_params.to_dict())

        return Computation.from_dict(res.json())

    # Alias for run_capsule
    run_pipeline = run_capsule

    def wait_until_completed(
        self,
        computation: Computation,
        polling_interval: float = 5,
        timeout: Optional[float] = None,
    ) -> Computation:
        """
        Poll a computation until it reaches 'Completed' or 'Failed' state with configurable timing.

        Args:
            computation: The computation object to monitor
            polling_interval: Time between status checks in seconds (minimum 5 seconds)
            timeout: Maximum time to wait in seconds, or None for no timeout

        Returns:
            Updated computation object once completed or failed

        Raises:
            ValueError: If polling_interval < 5 or timeout constraints are violated
            TimeoutError: If computation doesn't complete within the timeout period
        """
        if polling_interval < 5:
            raise ValueError(
                f"Polling interval {polling_interval} should be greater than or equal to 5"
            )
        if timeout is not None and timeout < polling_interval:
            raise ValueError(
                f"Timeout {timeout} should be greater than or equal to polling interval {polling_interval}"
            )
        if timeout is not None and timeout < 0:
            raise ValueError(
                f"Timeout {timeout} should be greater than or equal to 0 (seconds), or None"
            )
        t0 = time()
        while True:
            comp = self.get_computation(computation.id)

            if comp.state in [ComputationState.Completed, ComputationState.Failed]:
                return comp

            if timeout is not None and (time() - t0) > timeout:
                raise TimeoutError(
                    f"Computation {computation.id} did not complete within {timeout} seconds"
                )

            sleep(polling_interval)

    def attach_data_assets(
        self,
        computation_id: str,
        attach_params: list[DataAssetAttachParams],
    ) -> list[DataAssetAttachResults]:
        """Attach one or more data assets to a cloud workstation session computation."""
        res = self.client.post(
            f"computations/{computation_id}/data_assets",
            json=[j.to_dict() for j in attach_params],
        )
        return [DataAssetAttachResults.from_dict(c) for c in res.json()]

    def detach_data_assets(self, computation_id: str, data_assets: list[str]):
        """Detach one or more data assets from a cloud workstation session computation by their IDs."""
        self.client.delete(
            f"computations/{computation_id}/data_assets/",
            json=data_assets,
        )

    def list_computation_results(self, computation_id: str, path: str = "") -> Folder:
        """List result files and folders generated by a computation
        at the specified path. Empty path retrieves the /results root folder."""
        data = {
            "path": path,
        }

        res = self.client.post(f"computations/{computation_id}/results", json=data)

        return Folder.from_dict(res.json())

    def get_result_file_download_url(self, computation_id: str, path: str) -> DownloadFileURL:
        """[DEPRECATED] Generate a download URL for a specific result file from a computation.

        Deprecated: Use get_result_file_urls instead.
        """
        warn(
            "get_result_file_download_url is deprecated and will be removed in a future release. "
            "Use get_result_file_urls instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        res = self.client.get(
            f"computations/{computation_id}/results/download_url",
            params={"path": path},
        )

        return DownloadFileURL.from_dict(res.json())

    def get_result_file_urls(self, computation_id: str, path: str) -> FileURLs:
        """Generate view and download URLs for a specific result file from a computation."""
        res = self.client.get(
            f"computations/{computation_id}/results/urls",
            params={"path": path},
        )

        return FileURLs.from_dict(res.json())

    def delete_computation(self, computation_id: str):
        """Delete a computation and stop it if currently running."""
        self.client.delete(f"computations/{computation_id}")

    def rename_computation(self, computation_id: str, name: str):
        """Rename an existing computation with a new display name."""
        self.client.patch(f"computations/{computation_id}", params={"name": name})
